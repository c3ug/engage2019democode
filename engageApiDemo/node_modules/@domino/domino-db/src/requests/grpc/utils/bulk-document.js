/* Â©Copyright HCL Technologies Ltd. 2018 */
const messages = require('../generated/domino_pb.js');
const DominoDbError = require('../../../domino-db-error.js');
const { ERRORS } = require('../../../strings');
const { errorCodes, onError } = require('../../../constants.js');
const { decryptSecret } = require('./crypto-helpers.js');
const { meta } = require('../generated/pmeta.js');

const {
  makeGrpcError,
  makeProtonError,
  wrapError,
} = require('./grpc-helpers.js');

const verifyQuery = options => {
  if (!options.query) {
    throw new DominoDbError(
      ERRORS.BULK_OPERATION_NO_QUERY,
      errorCodes.BAD_REQUEST,
    );
  }
};

const makeNoteSearchReq = options => {
  const search = new messages.NoteSearchReq();
  search.setQuery(options.query);
  if (options.queryLimits) {
    const limits = options.queryLimits;
    if (limits.maxViewEntriesScanned) {
      search.setMaxEntriesScanned(limits.maxViewEntriesScanned);
    }
    if (limits.maxDocumentsScanned) {
      search.setMaxDocsScanned(limits.maxDocumentsScanned);
    }
    if (limits.maxMilliSeconds) {
      search.setMaxMilliSecs(limits.maxMilliSeconds);
    }
  }
  if (options.queryArgs) {
    const { queryArgs } = options;
    if (!Array.isArray(queryArgs)) {
      throw new DominoDbError(
        ERRORS.BAD_QUERY_ARGS_TYPE,
        errorCodes.BAD_REQUEST,
      );
    }
    const queryArgList = new messages.QueryArgList();
    queryArgs.forEach((arg, index) => {
      let value;
      const queryArg = new messages.QueryArg();
      if (typeof arg === 'object' && arg.value) {
        // Value is embedded in an object
        value = arg.value; // eslint-disable-line
        if (arg.ordinal) {
          queryArg.setOrdinal(arg.ordinal);
        } else {
          queryArg.setName(arg.name);
        }
      } else {
        // Argument is THE value; ordinal is implied
        value = arg;
        queryArg.setOrdinal(index + 1);
      }

      if (typeof value === 'string') {
        queryArg.setValueText(value);
      } else if (typeof value === 'number') {
        queryArg.setValueNumber(value);
      } else if (typeof value === 'object' && value.type === 'datetime') {
        queryArg.setValueTime(value.data);
      } else {
        throw new DominoDbError(
          ERRORS.BAD_QUERY_ARG_VALUE,
          errorCodes.BAD_REQUEST,
        );
      }
      queryArgList.addQueryArg(queryArg);
    });
    search.setQueryArgList(queryArgList);
  }
  return search;
};

const getBulkDocumentRequest = config => {
  const { itemNames } = config.options ? config.options : {};
  if (config.reqFunctionType === 'DELETE_ITEM' && !itemNames) {
    throw new DominoDbError(
      ERRORS.BULK_ITEM_DELETE_NO_ITEMS,
      errorCodes.BAD_REQUEST,
    );
  }
  const bulkDocumentReq = new messages.BulkNoteReq();
  // TODO we can switch between different servers through the same base url
  bulkDocumentReq.setServerName();

  bulkDocumentReq.setDatabaseFile(config.dbFilePath);
  if (config.documentListProto) {
    bulkDocumentReq.setNoteList(config.documentListProto);
  } else if (config.options.query) {
    const search = makeNoteSearchReq(config.options);
    bulkDocumentReq.setNoteSearch(search);

    // Paging controls
    if (config.options.start) {
      bulkDocumentReq.setNoteSkip(config.options.start);
    }
    if (config.options.count) {
      bulkDocumentReq.setNoteCount(config.options.count);
    }
  }
  bulkDocumentReq.addFunction(
    messages.BulkNoteFunction[config.reqFunctionType],
  );

  let onErrorValue = onError.CONTINUE;
  if (config.options && config.options.onErrorOptions) {
    onErrorValue = config.options.onErrorOptions;
  }
  bulkDocumentReq.addOption(messages.BulkNoteOption[onErrorValue]);

  if (config.options && Array.isArray(config.options.itemNames)) {
    const itemList = itemNames.map(item => {
      const itemProto = new messages.Item();
      itemProto.setName(item);
      return itemProto;
    });
    bulkDocumentReq.setItemList(itemList);
  }
  return bulkDocumentReq;
};

const executeBulkDocumentRequest = (
  bulkrequest,
  metadata,
  secrets,
  client,
  responseConverter,
) =>
  new Promise((resolve, reject) => {
    let responseMetadata;
    let requestMetadata = metadata;

    // Get password from secrets
    if (secrets && secrets.idFilePassword) {
      requestMetadata = metadata.clone();
      requestMetadata.add(
        meta.MDKEY_ID_FILE_PASSWORD,
        decryptSecret(secrets.idFilePassword),
      );
    }

    const call = client.bulkNote(
      bulkrequest,
      requestMetadata,
      (error, response) => {
        if (error) {
          reject(wrapError(makeGrpcError(error)));
          return;
        } else if (!response) {
          reject(
            wrapError(
              makeGrpcError(new Error(ERRORS.BULK_NOTE_REQUEST_FAILED)),
            ),
          );
          return;
        }

        let notes;
        if (response.getNoteList()) {
          notes = response.getNoteList().getNoteList();
        }

        if (!notes && response.hasRc()) {
          // The request failed completely. Throw an
          // exception.
          const rc = response.getRc();
          if (rc.getReturnCode()) {
            let queryError;
            const search = response.getNoteSearch();
            if (search) {
              queryError = search.getQueryError();
            }
            const newError = makeProtonError(rc, queryError, responseMetadata);
            reject(wrapError(newError));
            return;
          }
        }

        if (responseConverter) {
          // Convert response
          try {
            resolve(responseConverter(response));
          } catch (e) {
            reject(e);
          }
        } else {
          // Resolve with unconverted response
          resolve(response);
        }
      },
    );

    call.on('metadata', rmd => {
      responseMetadata = rmd;
    });
  });

module.exports = {
  getBulkDocumentRequest,
  executeBulkDocumentRequest,
  verifyQuery,
};
