/* Â©Copyright HCL Technologies Ltd. 2018 */
const DominoDbError = require('../../../domino-db-error.js');
const { ERRORS } = require('../../../strings');
const { errorCodes } = require('../../../constants.js');
const proton = require('../generated/errorcodes.js');
const { meta } = require('../generated/pmeta.js');
const grpc = require('grpc');

const makeGrpcHost = (hostName, connection) => {
  if (connection && connection.port) {
    return `${hostName}:${connection.port}`;
  }
  return `${hostName}:3002`;
};

const makeGrpcError = error => {
  const grpcError = new Error(ERRORS.GRPC_CLIENT_ERROR);
  grpcError.name = 'GrpcError';
  grpcError.cause = error;
  return grpcError;
};

const makeProtonError = (protoRc, queryError, responseMetadata) => {
  const code = protoRc.getReturnCode();
  let message = queryError;
  if (!message || !message.length) {
    message = protoRc.getErrorText();
  }
  if (!message || !message.length) {
    const errorObject = proton.errorcodes[`${code}`];
    if (errorObject && errorObject.msg) {
      message = `Proton (${code}): ${errorObject.msg}`;
    }
  }
  if (!message || !message.length) {
    message = ERRORS.BULK_NOTE_REQUEST_FAILED_WITH_CODE + code;
  }
  const error = new Error(message);
  error.name = 'ProtonError';
  error.code = code;
  if (responseMetadata && responseMetadata.get) {
    const values = responseMetadata.get(meta.MDKEY_PROTO_SEQUENCE_NUMBER);
    if (
      Array.isArray(values) &&
      values.length > 0 &&
      typeof values[0] === 'string'
    ) {
      error.protoSeq = parseInt(values[0], 10);
    }
  }
  return error;
};

const wrapError = error => {
  let code;
  if (error.name === 'GrpcError') {
    let grpcCode;
    if (error.cause) {
      grpcCode = error.cause.code;
    }
    switch (grpcCode) {
      case grpc.status.NOT_FOUND:
        code = errorCodes.NOT_FOUND;
        break;
      case grpc.status.FAILED_PRECONDITION:
        code = errorCodes.PRECONDITION_FAILED;
        break;
      case grpc.status.INVALID_ARGUMENT:
        code = errorCodes.BAD_REQUEST;
        break;
      case grpc.status.UNAUTHENTICATED:
      case grpc.status.PERMISSION_DENIED:
        code = errorCodes.NOT_AUTHORIZED;
        break;
      case grpc.status.UNAVAILABLE:
        code = errorCodes.NOT_CONNECTED;
        break;
      case grpc.status.DEADLINE_EXCEEDED:
        code = errorCodes.TIME_LIMIT_EXCEEDED;
        break;
      default:
        code = errorCodes.INTERNAL_ERROR;
    }
  } else if (error.name === 'ProtonError') {
    switch (error.code) {
      case 259: // Database not found
      case 546: // Item not found
      case 549: // Note has been deleted
        code = errorCodes.NOT_FOUND;
        break;
      case 527:
        code = errorCodes.TIME_LIMIT_EXCEEDED;
        break;
      case 1028: // Entry not found in index
      case 1173: // Query arg mismatch
      case 3849: // Bad query
      case 5910: // No certificate in address book
      case 6408: // Bad ID file password
      case 22792: // Bad ID file password
      case 65541: // Bad note UNID
      case 65544: // Bad request
      case 65545: // Bad time value
      case 65546: // Bad time pair value
      case 65547: // Bad time size value
      case 65548: // Bad number pair value
      case 65549: // Bad number size value
      case 65550: // Bad text size value
      case 65552: // Note count exceeded
      case 65559: // Bad query arg ID
      case 65560: // Bad query arg value
        code = errorCodes.BAD_REQUEST;
        break;
      case 582: // No access
      case 65553: // Not authorized
      case 65558: // No double encrypt
        code = errorCodes.FORBIDDEN;
        break;
      default:
        code = errorCodes.INTERNAL_ERROR;
    }
  } else {
    code = errorCodes.INTERNAL_ERROR;
  }
  return new DominoDbError(error.message, code, error);
};

const base64Encode = text => {
  const buffer = Buffer.from(text);
  const encodedText = buffer.toString('base64');
  buffer.fill(0); // Clear potential secret
  return encodedText;
};

const base64Decode = encodedText => {
  const buffer = Buffer.from(encodedText, 'base64');
  const text = buffer.toString('utf8');
  buffer.fill(0); // Clear potential encoded secret
  return text;
};

module.exports = {
  makeGrpcHost,
  makeGrpcError,
  makeProtonError,
  wrapError,
  base64Encode,
  base64Decode,
};
