/* Â©Copyright HCL Technologies Ltd. 2018 */
const messages = require('../generated/domino_pb.js');
const { makeProtonError, wrapError } = require('./grpc-helpers.js');

const parseItemDictionary = dictionary => {
  const result = {};
  if (dictionary) {
    const entries = dictionary.getEntryList();
    entries.forEach(entry => {
      result[entry.getKey()] = entry.getValue();
    });
  }
  return result;
};

const makePairList = flatList => {
  const pairList = [];
  let pair;

  flatList.forEach((value, index) => {
    if (!pair) {
      pair = [];
    }
    pair.push(value);
    if (index % 2) {
      pairList.push(pair);
      pair = undefined;
    }
  });

  return pairList;
};

const documentArrayFromDocumentListProto = documentListProto => {
  const result = [];
  const documents = documentListProto.getNoteList();
  const itemDictionary = parseItemDictionary(documentListProto.getItemDict());

  documents.forEach(doc => {
    const outputDoc = {};
    result.push(outputDoc);

    // Handle errors
    if (doc.hasRc()) {
      if (doc.getRc().getReturnCode()) {
        const error = wrapError(makeProtonError(doc.getRc()));
        outputDoc['@error'] = error;
        return;
      }
    }

    // Set the UNID
    outputDoc['@unid'] = doc.getUnid();
    const created = doc.getCreated();
    if (typeof created === 'string' && created.length > 0) {
      outputDoc['@created'] = {
        type: 'datetime',
        data: created,
      };
    }
    const modified = doc.getLastModified();
    if (typeof modified === 'string' && modified.length > 0) {
      outputDoc['@modified'] = {
        type: 'datetime',
        data: modified,
      };
    }

    // Output items
    const items = doc.getItemList();
    items.forEach(item => {
      let itemName;
      if (item.hasKey()) {
        itemName = itemDictionary[item.getKey()];
      } else {
        itemName = item.getName();
      }

      outputDoc[itemName] = 'x';
      const flags1 = item.getFlags1();
      const asSingleton = flags1 & messages.Item.Flags1.AS_SINGLETON; // eslint-disable-line
      const asPairs = flags1 & messages.Item.Flags1.AS_PAIRS; // eslint-disable-line
      const encrypt = flags1 & messages.Item.Flags1.ENCRYPT; // eslint-disable-line
      const nonsummary = flags1 & messages.Item.Flags1.NONSUMMARY; // eslint-disable-line

      // Calculate raw value
      let itemValue;
      if (asPairs) {
        if (item.hasValueTime()) {
          const flatList = item.getValueTime().getValueTimeList();
          const pairList = makePairList(flatList);
          itemValue = {
            type: 'datetime',
            data: pairList,
          };
        } else if (item.hasValueNumber()) {
          const flatList = item.getValueNumber().getValueNumberList();
          const pairList = makePairList(flatList);
          if (encrypt || nonsummary) {
            itemValue = {
              type: 'number',
              data: pairList,
            };
          } else {
            itemValue = pairList;
          }
        }
      } else if (item.hasValueText()) {
        let data;
        const value = item.getValueText().getValueTextList();
        if (asSingleton && value.length === 1) {
          data = value[0]; // eslint-disable-line
        } else {
          data = value;
        }
        if (encrypt || nonsummary) {
          itemValue = {
            type: 'text',
            data,
          };
        } else {
          itemValue = data;
        }
      } else if (item.hasValueTime()) {
        const value = item.getValueTime().getValueTimeList();
        itemValue = { type: 'datetime' };
        if (asSingleton && value.length === 1) {
          itemValue.data = value[0]; // eslint-disable-line
        } else {
          itemValue.data = value;
        }
      } else if (item.hasValueNumber()) {
        let data;
        const value = item.getValueNumber().getValueNumberList();
        if (asSingleton && value.length === 1) {
          data = value[0]; // eslint-disable-line
        } else {
          data = value;
        }
        if (encrypt || nonsummary) {
          itemValue = {
            type: 'number',
            data,
          };
        } else {
          itemValue = data;
        }
      }

      // Add item flags
      if (encrypt) {
        itemValue.encrypt = true;
      }
      if (nonsummary) {
        itemValue.nonsummary = true;
      }

      // Assign value to object property
      outputDoc[itemName] = itemValue;
    });
  });

  return result;
};

const readResponseFromProto = response => {
  const result = {};
  const documentListProto = response.getNoteList();
  result.documents = documentArrayFromDocumentListProto(documentListProto);
  result.errors = result.documents.reduce((count, document) => {
    if (document['@error']) {
      return count + 1;
    }
    return count;
  }, 0);

  result.documentRange = {
    total: response.getNoteTotal(),
    start: response.getNoteSkip(),
    count: result.documents.length,
  };

  return result;
};

// Used for everything except a read response (create, update, delete)
const commonResponseFromProto = (response, create) => {
  const result = {
    documents: [],
    errors: 0,
  };
  const documentListProto = response.getNoteList();
  if (documentListProto) {
    const documents = documentListProto.getNoteList();
    documents.forEach(document => {
      const outputDoc = {};
      result.documents.push(outputDoc);

      // Handle errors
      if (document.hasRc()) {
        if (document.getRc().getReturnCode()) {
          const error = wrapError(makeProtonError(document.getRc()));
          outputDoc['@error'] = error;
          result.errors += 1;
          return;
        }
      }

      const unid = document.getUnid();
      if (unid && unid.length > 0) {
        outputDoc['@unid'] = unid;
      }
    });
  }

  if (!create) {
    result.documentRange = {
      total: response.getNoteTotal(),
      start: response.getNoteSkip(),
      count: result.documents.length,
    };
  }

  return result;
};

const createResponseFromProto = response =>
  commonResponseFromProto(response, true);

const singleDocumentConverter = documentListProto => {
  const result = commonResponseFromProto(documentListProto);
  if (result && result.documents && result.documents.length > 0) {
    const doc = result.documents[0];
    const error = doc['@error'];
    if (error) {
      throw error;
    }
  }
};

const createSingleDocumentConverter = documentListProto => {
  const result = createResponseFromProto(documentListProto);
  if (result && result.documents && result.documents.length > 0) {
    const doc = result.documents[0];
    const error = doc['@error'];
    if (error) {
      throw error;
    } else {
      return doc['@unid'];
    }
  }
  return undefined;
};

const readSingleDocumentConverter = documentListProto => {
  const result = readResponseFromProto(documentListProto);
  if (result && result.documents && result.documents.length > 0) {
    const doc = result.documents[0];
    const error = doc['@error'];
    if (error) {
      throw error;
    } else {
      return doc;
    }
  }
  return undefined;
};

const explainQueryConverter = documentListProto => {
  const search = documentListProto.getNoteSearch();
  if (search) {
    return search.getQueryExplain();
  }
  return undefined;
};

module.exports = {
  singleDocumentConverter,
  createSingleDocumentConverter,
  readSingleDocumentConverter,
  explainQueryConverter,
  readResponseFromProto,
  createResponseFromProto,
  commonResponseFromProto,
};
