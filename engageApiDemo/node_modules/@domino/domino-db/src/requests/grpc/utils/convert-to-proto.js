/* Â©Copyright HCL Technologies Ltd. 2018 */
const messages = require('../generated/domino_pb.js');
const DominoDbError = require('../../../domino-db-error.js');
const { ERRORS } = require('../../../strings');
const { errorCodes } = require('../../../constants.js');

const getItemType = item => {
  if (typeof item === 'number') {
    return 'number';
  } else if (typeof item === 'string') {
    return 'string';
  } else if (typeof item === 'object' && !Array.isArray(item)) {
    if (item.type === 'datetime') {
      if (Array.isArray(item.data)) {
        if (Array.isArray(item.data[0])) {
          return 'pairs-of-date';
        }
        return 'repeating-date';
      }
      return 'date';
    } else if (item.type === 'number') {
      if (Array.isArray(item.data)) {
        if (Array.isArray(item.data[0])) {
          return 'pairs-of-number';
        }
        return 'repeating-number';
      }
      return 'number';
    } else if (item.type === 'text') {
      if (Array.isArray(item.data)) {
        return 'repeating-string';
      }
      return 'string';
    }
  } else if (Array.isArray(item)) {
    if (Array.isArray(item[0])) {
      const array = item[0];
      if (typeof array[0] === 'number') {
        return 'pairs-of-number';
      }
    } else {
      // Assumes all elements in array are of the same type
      return `repeating-${getItemType(item[0])}`;
    }
  }
  return undefined;
};

const addCommonItemFlags = (value, flags) => {
  let flags1 = flags;
  if (value.nonsummary) {
    flags1 += messages.Item.Flags1.NONSUMMARY;
  }
  if (value.encrypt) {
    flags1 += messages.Item.Flags1.ENCRYPT;
  }
  return flags1;
};

const itemProtoFromDocumentItem = ({ name, value, keyDictionary }) => {
  let itemValue;
  let flags1 = 0;
  const itemProto = new messages.Item();

  let key;
  if (keyDictionary) {
    key = keyDictionary[name];
  }

  if (key) {
    itemProto.setKey(key);
  } else {
    itemProto.setName(name);
  }

  let error;
  switch (getItemType(value)) {
    case 'number':
      flags1 += messages.Item.Flags1.AS_SINGLETON;
      itemValue = new messages.Item.ValueNumber();
      if (typeof value === 'object' && !Array.isArray(value)) {
        itemValue.setValueNumberList([value.data]);
        flags1 = addCommonItemFlags(value, flags1);
      } else {
        itemValue.setValueNumberList([value]);
      }
      itemProto.setValueNumber(itemValue);
      itemProto.setFlags1(flags1);
      break;
    case 'repeating-number':
      itemValue = new messages.Item.ValueNumber();
      if (typeof value === 'object' && !Array.isArray(value)) {
        itemValue.setValueNumberList(value.data);
        flags1 = addCommonItemFlags(value, flags1);
      } else {
        itemValue.setValueNumberList(value);
      }
      itemProto.setValueNumber(itemValue);
      itemProto.setFlags1(flags1);
      break;
    case 'pairs-of-number':
      {
        flags1 += messages.Item.Flags1.AS_PAIRS;
        let pairs = value;
        if (typeof value === 'object' && !Array.isArray(value)) {
          pairs = value.data;
          flags1 = addCommonItemFlags(value, flags1);
        }
        const flatList = [];
        pairs.forEach(pair => {
          if (pair.length !== 2) {
            throw new DominoDbError(
              ERRORS.DOC_CONVERSION_NUMBER_PAIR_LENGTH + name,
              errorCodes.BAD_REQUEST,
            );
          }
          flatList.push(pair[0]);
          flatList.push(pair[1]);
        });
        itemValue = new messages.Item.ValueNumber();
        itemValue.setValueNumberList(flatList);
        itemProto.setValueNumber(itemValue);
        itemProto.setFlags1(flags1);
      }
      break;
    case 'string':
      flags1 += messages.Item.Flags1.AS_SINGLETON;
      itemValue = new messages.Item.ValueText();
      if (typeof value === 'object') {
        itemValue.setValueTextList([value.data]);
        flags1 = addCommonItemFlags(value, flags1);
      } else {
        itemValue.setValueTextList([value]);
      }
      itemProto.setValueText(itemValue);
      itemProto.setFlags1(flags1);
      break;
    case 'repeating-string':
      itemValue = new messages.Item.ValueText();
      if (typeof value === 'object' && !Array.isArray(value)) {
        itemValue.setValueTextList(value.data);
        flags1 = addCommonItemFlags(value, flags1);
      } else {
        itemValue.setValueTextList(value);
      }
      itemProto.setValueText(itemValue);
      itemProto.setFlags1(flags1);
      break;
    case 'date':
      flags1 += messages.Item.Flags1.AS_SINGLETON;
      itemValue = new messages.Item.ValueTime();
      itemValue.setValueTimeList([value.data]);
      itemProto.setValueTime(itemValue);
      itemProto.setFlags1(addCommonItemFlags(value, flags1));
      break;
    case 'repeating-date':
      itemValue = new messages.Item.ValueTime();
      itemValue.setValueTimeList(value.data);
      itemProto.setValueTime(itemValue);
      itemProto.setFlags1(addCommonItemFlags(value, flags1));
      break;
    case 'pairs-of-date':
      {
        flags1 += messages.Item.Flags1.AS_PAIRS;
        const flatList = [];
        value.data.forEach(pair => {
          if (pair.length !== 2) {
            throw new DominoDbError(
              ERRORS.DOC_CONVERSION_DATETIME_PAIR_LENGTH + name,
              errorCodes.BAD_REQUEST,
            );
          }
          flatList.push(pair[0]);
          flatList.push(pair[1]);
        });
        itemValue = new messages.Item.ValueTime();
        itemValue.setValueTimeList(flatList);
        itemProto.setValueTime(itemValue);
        itemProto.setFlags1(addCommonItemFlags(value, flags1));
      }
      break;
    default:
      error = new DominoDbError(
        ERRORS.DOC_CONVERSION_UNKNOWN_ITEM_TYPE + name,
        errorCodes.BAD_REQUEST,
      );
  }
  if (error) {
    // Zero tolerance for conversion errors. We need to prevent
    // data loss before sending a request to the server.
    throw error;
  }
  return itemProto;
};

const itemListProtoFromDocument = (document, keyDictionary) =>
  Object.keys(document)
    .map(name => {
      if (name === '@unid') {
        return undefined; // undefined will get filtered out
      }
      const value = document[name];
      return itemProtoFromDocumentItem({ name, value, keyDictionary });
    })
    .filter(itemProto => itemProto); // Filter out the UNID fields

const makeKeyDictionary = documents => {
  let index = 1;
  const dictionary = {};
  documents.forEach(document => {
    Object.keys(document).forEach(itemName => {
      if (itemName === '@unid') return;

      if (!dictionary[itemName]) {
        dictionary[itemName] = `${index}`;
        index += 1;
      }
    });
  });
  return dictionary;
};

const itemDictionaryProtoFromKeyDictionary = keyDictionary => {
  const entries = [];
  Object.keys(keyDictionary).forEach(itemName => {
    const entry = new messages.KeyValueEntry();
    entry.setKey(keyDictionary[itemName]);
    entry.setValue(itemName);
    entries.push(entry);
  });
  const itemDictionaryProto = new messages.KeyValueDictionary();
  itemDictionaryProto.setEntryList(entries);
  return itemDictionaryProto;
};

const documentListProtoFromDocumentArray = documents => {
  const keyDictionary = makeKeyDictionary(documents);
  const documentList = [].concat(documents).map(document => {
    const documentProto = new messages.Note();
    const documentClone = { ...document };
    if (documentClone['@unid']) {
      documentProto.setUnid(document['@unid']);
      delete documentClone['@unid'];
    }
    documentProto.setItemList(
      itemListProtoFromDocument(documentClone, keyDictionary),
    );
    return documentProto;
  });
  const documentListProto = new messages.NoteList();
  documentListProto.setNoteList(documentList);
  const itemDictionaryProto = itemDictionaryProtoFromKeyDictionary(
    keyDictionary,
  );
  documentListProto.setItemDict(itemDictionaryProto);
  return documentListProto;
};

const documentListProtoFromUnidArray = unids => {
  const documents = unids.map(unid => {
    const document = new messages.Note();
    document.setUnid(unid);
    return document;
  });

  const documentListProto = new messages.NoteList();
  documentListProto.setNoteList(documents);

  return documentListProto;
};

module.exports = {
  documentListProtoFromDocumentArray,
  documentListProtoFromUnidArray,
  itemListProtoFromDocument,
};
